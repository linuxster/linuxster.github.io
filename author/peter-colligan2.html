<!DOCTYPE html>
<html lang="en">
<head>
        <title>Atoms 2 Bits - Articles by Peter Colligan</title>
        <meta charset="utf-8" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Atoms 2 Bits Full Atom Feed" />
        <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Atoms 2 Bits Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="">Atoms 2 Bits <strong>Musings and ramblings through the world of enterprise analytics</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/archives.html">Archives</a></li>
            <li><a href="http://www.astro.washington.edu/users/vanderplas">Home Page</a></li>
              <li><a href="/category/misc.html">misc</a></li>
        </ul></nav><!-- /#menu -->
<section id="content">
<h2>Articles by Peter Colligan</h2>

<ol id="post-list">
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/09/20/why-python-is-the-last/" rel="bookmark" title="Permalink to Why Python is the Last Language You'll Have To Learn">Why Python is the Last Language You'll Have To Learn</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-09-20T20:50:00"> Sep 20, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p>This week, for part of a textbook I'm helping to write,
I spent some time reading and researching the history of Python as
a scientific computing tool.  I had heard bits and pieces of this in the past,
but it was fascinating to put it all together and learn about how all the
individual contributions that have made Python what it is today.
All of this got me thinking: for most of us, Python was a replacement for
something: IDL, MatLab, Java, Mathematica, Perl... you name it.
But what will replace Python?
Ten years down the road, what language will people be espousing in
blogs with awkwardly-alliterated titles?  As I thought it through, I
became more and more convinced that, at least in the scientific computing
world, Python is here to stay.</p>
 </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/09/12/dynamic-programming-in-python/" rel="bookmark" title="Permalink to Dynamic Programming in Python: Bayesian Blocks">Dynamic Programming in Python: Bayesian Blocks</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-09-12T19:02:00"> Sep 12, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p>Of all the programming styles I have learned,
<a href="http://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>
is perhaps the most beautiful.  It can take problems that, at first glance,
look ugly and intractable, and solve the problem with clean, concise code.
Where a simplistic algorithm might accomplish something by brute force,
dynamic programming steps back, breaks the task into a smaller set of
sequential parts, and then proceeds in the most efficient way possible.</p>
<h3>Bayesian Blocks</h3>
<p>I'll go through an example here where the ideas of dynamic programming
are vital to some very cool data analysis resuts.
This post draws heavily from a recent
<a href="http://adsabs.harvard.edu/abs/2012arXiv1207.5578S">paper</a> by Jeff Scargle
and collaborators (this is the Scargle of <em>Lomb-Scargle Periodogram</em>
fame), as well as some conversations I had with Jeff at
<a href="http://www.astro.caltech.edu/ai12/">Astroinformatics 2012</a>.
The paper discusses
a framework called <em>Bayesian Blocks</em>, which is essentially a method of
creating histograms with bin sizes that adapt to the data (there's a bit
more to it than that: here we'll focus on histograms for simplicity).</p>
 </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/09/05/quantum-python/" rel="bookmark" title="Permalink to Quantum Python: Animating the Schrodinger Equation">Quantum Python: Animating the Schrodinger Equation</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-09-05T20:12:00"> Sep 05, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p><em>Update: a reader contributed some improvements to the Python code presented
 below.  Please see the
<a href="https://github.com/jakevdp/pySchrodinger">pySchrodinger</a> github repository
for updated code</em></p>
<p>In a <a href="/blog/2012/08/18/matplotlib-animation-tutorial/">previous post</a>
I explored the new animation capabilities of the latest
<a href="http://matplotlib.sourceforge.net">matplotlib</a> release.
It got me wondering whether it would be possible to simulate more complicated
physical systems in real time in python.  Quantum Mechanics was the first
thing that came to mind.  It turns out that by mixing a bit of Physics
knowledge with a bit of computing knowledge, it's quite straightforward
to simulate and animate a simple quantum mechanical system with python.</p>
<h2>The Schrodinger Equation</h2>
<p>The dynamics of a one-dimensional quantum system are governed by the
time-dependent Schrodinger equation:</p>
<p>$$
i\hbar\frac{\partial \psi}{\partial t}
  = \frac{-\hbar^2}{2m} \frac{\partial^2 \psi}{\partial x^2} + V \psi
$$</p>
 </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/08/24/numba-vs-cython/" rel="bookmark" title="Permalink to Numba vs Cython">Numba vs Cython</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-08-24T10:41:00"> Aug 24, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p><em>For a more up-to-date comparison of Numba and Cython, see the</em>
<a href="http://jakevdp.github.io/blog/2013/06/15/numba-vs-cython-take-2/"><em>newer post</em></a>
<em>on this subject.</em></p>
<p>Often I'll tell people that I use python for computational analysis, and they
look at me inquisitively.  "Isn't python pretty slow?"  They have a point.
Python is an interpreted language, and as such cannot natively perform
many operations as quickly as a compiled language such as C or Fortran.
There is also the issue of the oft-misunderstood and much-maligned
<a href="http://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>,
which calls into question python's ability to allow true parallel computing.</p>
<p>Many solutions have been proposed: <a href="http://pypy.org/">PyPy</a> is a much faster
version of the core python language; 
<a href="http://code.google.com/p/numexpr/">numexpr</a> provides optimized performance
on certain classes of operations from within python;
<a href="http://www.scipy.org/Weave/">weave</a> allows inline inclusion of compiled
C/C++ code;
<a href="http://www.cython.org/">cython</a> provides extra markup that allows python
and/or python-like code to be compiled into C for fast operations.  But
a naysayer might point out: many of these "python" solutions in practice
are not really python at all, but clever hacks into Fortran or C.</p>
 </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/08/18/matplotlib-animation-tutorial/" rel="bookmark" title="Permalink to Matplotlib Animation Tutorial">Matplotlib Animation Tutorial</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-08-18T08:01:00"> Aug 18, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p><a href="http://matplotlib.sourceforge.net">Matplotlib</a> version 1.1 added some tools
for creating
<a href="http://matplotlib.sourceforge.net/api/animation_api.html">animations</a>
which are really slick.  You can find some good example animations on
the matplotlib
<a href="http://matplotlib.sourceforge.net/examples/animation/index.html">examples</a>
page.  I thought I'd share here some of the things I've learned when playing
around with these tools.</p>
<h3>Basic Animation</h3>
<p>The animation tools center around the <code>matplotlib.animation.Animation</code> base
class, which provides a framework around which the animation functionality
is built.  The main interfaces are <code>TimedAnimation</code> and <code>FuncAnimation</code>,
which you can read more about in the
<a href="http://matplotlib.sourceforge.net/api/animation_api.html">documentation</a>.
Here I'll explore using the <code>FuncAnimation</code> tool, which I have found
to be the most useful.</p>
 </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/08/16/memoryview-benchmarks-2/" rel="bookmark" title="Permalink to Memoryview Benchmarks 2">Memoryview Benchmarks 2</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-08-16T14:19:00"> Aug 16, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p>In the <a href="/blog/2012/08/08/memoryview-benchmarks/">previous post</a>, I explored
how cython typed memoryviews can be used to speed up repeated array
operations.  It became clear that typed memoryviews are superior to
the ndarray syntax for slicing, and as fast as raw pointers for single
element access.  In the comments, Mathieu brought up an interesting
question: is the ndarray syntax as good as typed memoryviews if you're
not doing slicing?</p>
<p>The answer turns out to be yes, <em>unless</em> the compiler tries to inline your
function.</p>
 </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="/blog/2012/08/08/memoryview-benchmarks/" rel="bookmark" title="Permalink to Memoryview Benchmarks">Memoryview Benchmarks</a></h2> </header>
                <footer class="post-info">
                    <abbr class="published" title="2012-08-08T18:50:00"> Aug 08, 2012 </abbr>
<address class="vcard author">By <a class="url fn" href="/author/peter-colligan.html">Peter Colligan</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> 

<p>There was recently a <a href="https://groups.google.com/forum/?fromgroups#!topic/cython-users/8uuxjB_wbBQ[1-25]" title="cython-users archive">thread</a>
on cython-users which caught my eye.  It has to do with 
<a href="http://docs.cython.org/src/userguide/memoryviews.html">memoryviews</a>, a new
way of working with memory buffers in cython.</p>
<p>I've been thinking recently about how to do fast
and flexible memory buffer access in cython.  I contributed the
<a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html">BallTree</a>
implementation for nearest neighbors searching in
<a href="http://www.scikit-learn.org">scikit-learn</a>, and have been actively thinking
about how to make it faster and more flexible, including adding the ability
to specify distance metrics other than euclidean and minkowski.</p>
<p>In order to accomplish this, I'd like to have a set of distance metric
functions which take two vectors and compute a distance.  There would
be many functions with similar call signatures which could then be
plugged into a code that would iterate over a set of vectors and
compute the appropriate distances.</p>
 </div><!-- /.entry-content -->
        </article></li>
</ol><!-- /#posts-list -->
<p class="paginator">
        <a href="/author/peter-colligan.html">&laquo;</a>
    Page 2 / 2
</p>
</section><!-- /#content -->
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>